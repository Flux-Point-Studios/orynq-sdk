/**
 * @summary Forward middleware for proxying verified requests to the backend.
 *
 * This file creates an HTTP proxy middleware that forwards requests to the
 * backend service after payment has been verified. It sets trusted headers
 * that the backend can use to skip its own payment verification.
 *
 * The middleware:
 * - Generates deterministic invoice IDs for tracking
 * - Sets the trusted "X-Paid-Verified: 1" header
 * - Forwards wallet address information
 * - Handles proxy errors gracefully
 *
 * Used by:
 * - server.ts for forwarding verified requests
 */

import { createProxyMiddleware, type RequestHandler, type Options } from "http-proxy-middleware";
import type { Request, Response, NextFunction } from "express";
import type { IncomingMessage, ServerResponse } from "http";
import { FLUX_HEADERS } from "@fluxpointstudios/poi-sdk-core";
import type { GatewayConfig } from "./config.js";
import { generateInvoiceIdSync } from "./invoice-bridge.js";

// ---------------------------------------------------------------------------
// Types
// ---------------------------------------------------------------------------

/**
 * Extended request with invoice information attached by the gateway.
 */
export interface GatewayRequest extends Request {
  /**
   * Invoice ID generated by the gateway.
   */
  gatewayInvoiceId?: string;

  /**
   * Whether payment has been verified.
   */
  paymentVerified?: boolean;

  /**
   * Transaction hash from payment (if available).
   */
  paymentTxHash?: string;
}

/**
 * Proxy event handlers for customization.
 */
export interface ForwardEventHandlers {
  /**
   * Called before request is forwarded to backend.
   */
  onBeforeForward?: (req: GatewayRequest, invoiceId: string) => void;

  /**
   * Called after response is received from backend.
   */
  onAfterForward?: (req: GatewayRequest, res: Response, invoiceId: string) => void;

  /**
   * Called when proxy encounters an error.
   */
  onForwardError?: (err: Error, req: GatewayRequest, invoiceId: string) => void;
}

// ---------------------------------------------------------------------------
// Middleware Factory
// ---------------------------------------------------------------------------

/**
 * Create a proxy middleware that forwards verified requests to the backend.
 *
 * The middleware adds trusted headers that tell the backend the payment has
 * already been verified by the gateway:
 * - X-Paid-Verified: 1 (or configured trustedHeader)
 * - X-Invoice-Id: <generated invoice ID>
 * - X-Wallet-Address: <payer's wallet> (if available)
 *
 * @param config - Gateway configuration
 * @param handlers - Optional event handlers for customization
 * @returns Express middleware that proxies to the backend
 *
 * @example
 * ```typescript
 * const config: GatewayConfig = {
 *   backendUrl: "http://localhost:8000",
 *   payTo: "0x...",
 *   chains: ["eip155:8453"],
 *   pricing: async () => ({ chain: "eip155:8453", asset: "USDC", amountUnits: "1000000" }),
 * };
 *
 * const forwardMiddleware = createForwardMiddleware(config);
 *
 * // Use after payment verification
 * app.use("/api/*", paymentMiddleware, forwardMiddleware);
 * ```
 */
export function createForwardMiddleware(
  config: GatewayConfig,
  handlers?: ForwardEventHandlers
): RequestHandler {
  const trustedHeader = config.trustedHeader ?? "X-Paid-Verified";
  const debug = config.debug ?? false;

  const proxyOptions: Options = {
    target: config.backendUrl,
    changeOrigin: true,

    // Modify request before forwarding
    onProxyReq(proxyReq, req, _res) {
      const expressReq = req as GatewayRequest;
      const originalReq = req as IncomingMessage;

      // Generate invoice ID for tracking
      const idempotencyKey = expressReq.headers["x-idempotency-key"] as string | undefined;
      const invoiceId =
        expressReq.gatewayInvoiceId ??
        generateInvoiceIdSync(originalReq.method ?? "GET", originalReq.url ?? "/", idempotencyKey);

      // Store on request for handlers
      expressReq.gatewayInvoiceId = invoiceId;

      // Set trusted header - backend will skip payment verification
      proxyReq.setHeader(trustedHeader, "1");
      proxyReq.setHeader(FLUX_HEADERS.INVOICE_ID, invoiceId);

      // Forward wallet address if available
      const walletAddress = expressReq.headers["x-wallet-address"];
      if (walletAddress) {
        proxyReq.setHeader(FLUX_HEADERS.WALLET_ADDRESS, walletAddress as string);
      }

      // Forward payment transaction hash if available
      if (expressReq.paymentTxHash) {
        proxyReq.setHeader(FLUX_HEADERS.TX_HASH, expressReq.paymentTxHash);
      }

      // Forward idempotency key if present
      if (idempotencyKey) {
        proxyReq.setHeader(FLUX_HEADERS.IDEMPOTENCY_KEY, idempotencyKey);
      }

      // Debug logging
      if (debug) {
        console.log(`[Gateway] Forwarding ${originalReq.method} ${originalReq.url} to ${config.backendUrl}`);
        console.log(`[Gateway] Invoice ID: ${invoiceId}`);
        console.log(`[Gateway] ${trustedHeader}: 1`);
      }

      // Call handler if provided
      if (handlers?.onBeforeForward) {
        handlers.onBeforeForward(expressReq, invoiceId);
      }
    },

    // Handle proxy response
    onProxyRes(proxyRes, req, _res) {
      const expressReq = req as GatewayRequest;
      const invoiceId = expressReq.gatewayInvoiceId ?? "unknown";

      if (debug) {
        console.log(`[Gateway] Backend response: ${proxyRes.statusCode} for ${invoiceId}`);
      }

      // Note: onAfterForward is limited in what it can do with the response
      // since http-proxy-middleware controls the response stream
      if (handlers?.onAfterForward) {
        handlers.onAfterForward(expressReq, _res as unknown as Response, invoiceId);
      }
    },

    // Handle proxy errors
    onError(err, req, res) {
      const expressReq = req as GatewayRequest;
      const invoiceId = expressReq.gatewayInvoiceId ?? "unknown";

      console.error(`[Gateway] Proxy error for ${invoiceId}:`, err.message);

      // Call handler if provided
      if (handlers?.onForwardError) {
        handlers.onForwardError(err, expressReq, invoiceId);
      }

      // Send error response
      const serverRes = res as ServerResponse;
      if (!serverRes.headersSent) {
        serverRes.writeHead(502, { "Content-Type": "application/json" });
        serverRes.end(
          JSON.stringify({
            error: "Backend unavailable",
            message: err.message,
            invoiceId,
          })
        );
      }
    },
  };

  return createProxyMiddleware(proxyOptions);
}

// ---------------------------------------------------------------------------
// Simple Forward Function
// ---------------------------------------------------------------------------

/**
 * Create a simple forward handler without full proxy middleware.
 *
 * This is useful for testing or when you need more control over the
 * forwarding process.
 *
 * @param config - Gateway configuration
 * @returns Express middleware function
 */
export function createSimpleForwardHandler(
  config: GatewayConfig
): (req: Request, res: Response, next: NextFunction) => Promise<void> {
  const trustedHeader = config.trustedHeader ?? "X-Paid-Verified";

  return async (req: Request, res: Response, next: NextFunction) => {
    try {
      const gatewayReq = req as GatewayRequest;
      const idempotencyKey = req.headers["x-idempotency-key"] as string | undefined;
      const invoiceId =
        gatewayReq.gatewayInvoiceId ??
        generateInvoiceIdSync(req.method, req.url, idempotencyKey);

      // Build target URL
      const targetUrl = new URL(req.originalUrl, config.backendUrl);

      // Build headers
      const forwardHeaders: Record<string, string> = {};

      // Copy original headers
      for (const [key, value] of Object.entries(req.headers)) {
        if (value && typeof value === "string" && !isHopByHopHeader(key)) {
          forwardHeaders[key] = value;
        }
      }

      // Set trusted headers
      forwardHeaders[trustedHeader] = "1";
      forwardHeaders[FLUX_HEADERS.INVOICE_ID] = invoiceId;

      // Forward wallet address if available
      const walletAddress = req.headers["x-wallet-address"];
      if (walletAddress && typeof walletAddress === "string") {
        forwardHeaders[FLUX_HEADERS.WALLET_ADDRESS] = walletAddress;
      }

      // Make request to backend
      const fetchInit: RequestInit = {
        method: req.method,
        headers: forwardHeaders,
      };

      // Only set body for methods that support it
      if (req.method !== "GET" && req.method !== "HEAD") {
        fetchInit.body = JSON.stringify(req.body);
      }

      const response = await fetch(targetUrl.toString(), fetchInit);

      // Copy response status and headers
      res.status(response.status);

      for (const [key, value] of response.headers.entries()) {
        if (!isHopByHopHeader(key)) {
          res.setHeader(key, value);
        }
      }

      // Stream response body
      if (response.body) {
        const reader = response.body.getReader();
        const pump = async (): Promise<void> => {
          const { done, value } = await reader.read();
          if (done) {
            res.end();
            return;
          }
          res.write(value);
          return pump();
        };
        await pump();
      } else {
        res.end();
      }
    } catch (error) {
      next(error);
    }
  };
}

// ---------------------------------------------------------------------------
// Utilities
// ---------------------------------------------------------------------------

/**
 * Headers that should not be forwarded (hop-by-hop headers).
 */
const HOP_BY_HOP_HEADERS = new Set([
  "connection",
  "keep-alive",
  "proxy-authenticate",
  "proxy-authorization",
  "te",
  "trailers",
  "transfer-encoding",
  "upgrade",
  "host",
]);

/**
 * Check if a header is a hop-by-hop header that shouldn't be forwarded.
 */
function isHopByHopHeader(name: string): boolean {
  return HOP_BY_HOP_HEADERS.has(name.toLowerCase());
}
